# NEW WORKFLOW - Testing phase
# This replaces deploy_prod.yml with improved features:
# - Migration detection for smart preboot toggle
# - Shared Docker build workflow for better caching and consistency
#
# TODO: Once validated, deprecate and delete deploy_prod.yml

name: Deploy PRODUCTION (v2)

on:
  workflow_dispatch:

permissions:
  contents: read
  packages: write
  deployments: write

jobs:
  # Check for migrations to determine preboot setting
  check-migrations:
    runs-on: ubuntu-24.04
    outputs:
      has_migrations: ${{ steps.check.outputs.has_migrations }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Check for migrations since last deployment
        id: check
        run: |
          ./scripts/check_migrations_since_deploy.sh \
            "${{ github.repository_owner }}" \
            "${{ github.event.repository.name }}" \
            "prod_env" \
            "${{ github.sha }}" \
            "${{ github.ref_name }}"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Build Docker image using shared workflow
  build:
    uses: ./.github/workflows/docker_build.yml
    with:
      # Production gets latest tag (SHA tag is always included)
      include_latest_tag: true
      heroku_app: metaculus-web
    secrets: inherit

  # Deploy to Heroku
  deploy:
    needs: [check-migrations, build]
    runs-on: ubuntu-24.04
    environment: prod_env
    env:
      HEROKU_API_KEY: ${{ secrets.HEROKU_API_KEY }}
      HEROKU_APP: metaculus-web

    steps:
      - name: Install Heroku CLI
        run: curl https://cli-assets.heroku.com/install-ubuntu.sh | sh

      - name: Configure preboot based on migration status
        run: |
          if [ "${{ needs.check-migrations.outputs.has_migrations }}" == "true" ]; then
            echo "üóÑÔ∏è Migrations detected - disabling preboot to ensure migrations run before new code"
            heroku features:disable preboot -a ${{ env.HEROKU_APP }}
          else
            echo "‚úÖ No migrations - enabling preboot for zero-downtime deployment"
            heroku features:enable preboot -a ${{ env.HEROKU_APP }}
          fi

      - name: Checkout scripts
        uses: actions/checkout@v6
        with:
          sparse-checkout: scripts
          sparse-checkout-cone-mode: false

      - name: Deploy to Heroku
        run: |
          heroku container:release ${{ needs.build.outputs.heroku_targets }} -a ${{ env.HEROKU_APP }}

      - name: Wait for release to complete
        run: ./scripts/wait_for_heroku_release.sh "${{ env.HEROKU_APP }}" 90

      - name: "Cloudflare: Purge cache"
        run: |
          # Capture response and HTTP status
          HTTP_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/purge_cache" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}')
          
          # Split response body and status code
          HTTP_BODY=$(echo "$HTTP_RESPONSE" | sed '$d')
          HTTP_STATUS=$(echo "$HTTP_RESPONSE" | tail -n1)
          
          echo "HTTP Status: $HTTP_STATUS"
          echo "Response: $HTTP_BODY"
          
          # Check HTTP status
          if [ "$HTTP_STATUS" -lt 200 ] || [ "$HTTP_STATUS" -ge 300 ]; then
            echo "::warning::Cloudflare cache purge failed with HTTP status $HTTP_STATUS"
            exit 0  # Don't fail the workflow
          fi
          
          # Check JSON success field
          SUCCESS=$(echo "$HTTP_BODY" | jq -r '.success // false')
          if [ "$SUCCESS" != "true" ]; then
            ERRORS=$(echo "$HTTP_BODY" | jq -r '.errors // []')
            echo "::warning::Cloudflare cache purge returned success=false. Errors: $ERRORS"
            exit 0  # Don't fail the workflow
          fi
          
          echo "‚úÖ Cloudflare cache purged successfully"

      - name: "Sentry: Upload sourcemaps"
        run: |
          docker run -w /app/front_end -e SENTRY_AUTH_TOKEN=${{ secrets.SENTRY_AUTH_TOKEN }} ${{ needs.build.outputs.image_url }} npx sentry-cli sourcemaps upload /app/front_end/.next/ --project metaculus-frontend --org metaculus

      - name: Disable preboot (reset to safe default)
        if: always()
        run: |
          echo "Disabling preboot to ensure safe state for legacy deployment scripts"
          heroku features:disable preboot -a ${{ env.HEROKU_APP }} || true

  # Deploy storybook to Cloudflare Pages
  deploy-storybook:
    needs: [deploy]
    permissions:
      contents: read
    uses: ./.github/workflows/storybook.yml
    secrets: inherit